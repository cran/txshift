<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Nima Hejazi and David Benkeser" />

<meta name="date" content="2022-02-09" />

<title>Evaluating Causal Effects of Modified Treatment Policies</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Evaluating Causal Effects of Modified Treatment Policies</h1>
<h4 class="author"><a href="https://nimahejazi.org">Nima Hejazi</a> and <a href="https://www.sph.emory.edu/faculty/profile/#!dbenkes">David Benkeser</a></h4>
<h4 class="date">2022-02-09</h4>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Stochastic treatment regimes constitute a flexible framework for evaluating the effects of continuous-valued exposures/treatments. <em>Modified treatment policies</em>, one such technique within this framework, examine the effects attributable to shifting the observed (“natural”) value of a treatment, usually up or down by some scalar <span class="math inline">\(\delta\)</span>. The <code>txshift</code> package implements algorithms for computing one-step or targeted minimum loss-based (TML) estimates of the counterfactual means induced by additive modified treatment policies (MTPs), defined by a shifting function <span class="math inline">\(\delta(A,W)\)</span>. For a technical presentation, the interested reader is invited to consult <span class="citation">Dı́az and van der Laan (2018)</span> or the earlier work of <span class="citation">Dı́az and van der Laan (2012)</span> and <span class="citation">Haneuse and Rotnitzky (2013)</span>. For background on Targeted Learning, consider consulting <span class="citation">van der Laan and Rose (2011)</span>, <span class="citation">van der Laan and Rose (2018)</span>, and <span class="citation">van der Laan et al. (2022)</span>.</p>
<p>To start, let’s load the packages we’ll need and set a seed for simulation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(data.table)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">library</span>(haldensify)</a></code></pre></div>
<pre><code>## haldensify v0.2.3: Highly Adaptive Lasso Conditional Density Estimation</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">library</span>(txshift)</a></code></pre></div>
<pre><code>## txshift v0.3.8: Efficient Estimation of the Causal Effects of Stochastic Interventions</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">set.seed</span>(<span class="dv">11249</span>)</a></code></pre></div>
<hr />
</div>
<div id="data-and-notation" class="section level2">
<h2>Data and Notation</h2>
<p>We’ll consider <span class="math inline">\(n\)</span> observed units <span class="math inline">\(O_1, \ldots, O_n\)</span>, where each random variable <span class="math inline">\(O = (W, A, Y)\)</span> corresponds to the data available on a single unit. Within <span class="math inline">\(O\)</span>, <span class="math inline">\(W\)</span> denotes baseline covariates (e.g., age, biological sex, BMI), <span class="math inline">\(A \in \mathbb{R}\)</span> a continuous-valued exposure (e.g., dosage of nutritional supplements taken), and <span class="math inline">\(Y\)</span> an outcome of interest (e.g., disease status). To minimize unjustifiable assumptions, we let <span class="math inline">\(O \sim \mathcal{P} \in \mathcal{M}\)</span>, where <span class="math inline">\(\mathcal{P}\)</span> is simply any distribution within the nonparametric statistical model <span class="math inline">\(\mathcal{M}\)</span>. To formalize the definition of stochastic interventions and their corresponding causal effects, we consider a nonparametric structural equation model (NPSEM), introduced by <span class="citation">Pearl (2000)</span>, to define how the system changes under interventions of interest: <span class="math display">\[\begin{align*}\label{eqn:npsem}
  W &amp;= f_W(U_W) \\ A &amp;= f_A(W, U_A) \\ Y &amp;= f_Y(A, W, U_Y),
\end{align*}\]</span> We denote the observed data structure <span class="math inline">\(O = (W, A, Y)\)</span></p>
<p>Assuming that the distribution of <span class="math inline">\(A\)</span> conditional on <span class="math inline">\(W = w\)</span> has support in the interval <span class="math inline">\((l(w), u(w))\)</span> – for convenience, we assume that the minimum natural value of treatment <span class="math inline">\(A\)</span> for an individual with covariates <span class="math inline">\(W = w\)</span> is <span class="math inline">\(l(w)\)</span>, while, similarly, the maximum is <span class="math inline">\(u(w)\)</span> – a simple MTP based on a shift <span class="math inline">\(\delta\)</span>, is <span class="math display">\[\begin{equation}\label{eqn:shift}
  \delta(a, w) =
  \begin{cases}
    a - \delta &amp; \text{if } a &gt; l(w) + \delta \\
    a &amp; \text{if } a \leq l(w) + \delta,
  \end{cases}
\end{equation}\]</span> where <span class="math inline">\(0 \leq \delta\)</span> is an arbitrary pre-specified value that defines the degree to which the observed value <span class="math inline">\(A\)</span> is to be shifted, where possible.</p>
<p>In case-cohort studies, it is common practice to make use of outcome-dependent two-phase sampling designs, which allow for expensive measurements made on the exposure (e.g., genomic sequencing of immune markers) to be avoided. As a complication, such sampling schemes alter the observed data structure from the simpler <span class="math inline">\(O = (W, A, Y)\)</span> to <span class="math inline">\(O = (W, \Delta A, Y, \Delta)\)</span>, where the sampling indicator <span class="math inline">\(\Delta\)</span> may itself be a function of the variables <span class="math inline">\(\{W, Y\}\)</span>. In this revised data structure, the value of <span class="math inline">\(A\)</span> is only observed for units in the two-phase sample, for whom <span class="math inline">\(\Delta = 1\)</span>. <span class="citation">Hejazi et al. (2020)</span> provide a detailed investigation of the methodological details of efficient estimation under such designs in the context of vaccine efficacy trials; their work was used in the analysis of immune correlates of protection for HIV-1 <span class="citation">(Hejazi et al. 2020)</span> and COVID-19 <span class="citation">(Gilbert et al. 2021)</span>. Of course, one may also account for loss to follow-up (i.e., censoring), which the <code>txshift</code> package supports (through the <code>C_cens</code> argument of the eponymous <code>txshift</code> function), though we avoid this complication in our subsequent examples in the interest of clarity of exposition. Corrections for both censoring and two-phase sampling make use of inverse probability of censoring weighting (IPCW), leading to IPCW-augmented one-step and TML estimators.</p>
<div id="simulate-data" class="section level3">
<h3>Simulate Data</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1"><span class="co"># parameters for simulation example</span></a>
<a class="sourceLine" id="cb6-2" title="2">n_obs &lt;-<span class="st"> </span><span class="dv">200</span>  <span class="co"># number of observations</span></a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co"># baseline covariate -- simple, binary</span></a>
<a class="sourceLine" id="cb6-5" title="5">W &lt;-<span class="st"> </span><span class="kw">rbinom</span>(n_obs, <span class="dv">1</span>, <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co"># create treatment based on baseline W</span></a>
<a class="sourceLine" id="cb6-8" title="8">A &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n_obs, <span class="dt">mean =</span> <span class="dv">2</span> <span class="op">*</span><span class="st"> </span>W, <span class="dt">sd =</span> <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="co"># create outcome as a linear function of A, W + white noise</span></a>
<a class="sourceLine" id="cb6-11" title="11">Y &lt;-<span class="st"> </span>A <span class="op">+</span><span class="st"> </span>W <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(n_obs, <span class="dt">mean =</span> <span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="co"># two-phase sampling based on covariates</span></a>
<a class="sourceLine" id="cb6-14" title="14">Delta_samp &lt;-<span class="st"> </span><span class="kw">rbinom</span>(n_obs, <span class="dv">1</span>, <span class="kw">plogis</span>(W))</a>
<a class="sourceLine" id="cb6-15" title="15"></a>
<a class="sourceLine" id="cb6-16" title="16"><span class="co"># treatment shift parameter</span></a>
<a class="sourceLine" id="cb6-17" title="17">delta &lt;-<span class="st"> </span><span class="fl">0.5</span></a></code></pre></div>
</div>
</div>
<div id="estimating-the-effects-of-additive-mtps" class="section level2">
<h2>Estimating the Effects of Additive MTPs</h2>
<p>The simplest way to compute an efficient estimator for an additive MTP is to fit each of the nuisance parameters internally. This procedure can be sped up by using generalized linear models (GLMs) to fit the outcome regression <span class="math inline">\(Q_n\)</span>. The <code>txshift()</code> function provides a simple interface.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1">est_shift &lt;-<span class="st"> </span><span class="kw">txshift</span>(</a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="dt">W =</span> W, <span class="dt">A =</span> A, <span class="dt">Y =</span> Y, <span class="dt">delta =</span> delta,</a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="dt">g_exp_fit_args =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="dt">fit_type =</span> <span class="st">&quot;hal&quot;</span>, <span class="dt">n_bins =</span> <span class="dv">5</span>,</a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="dt">grid_type =</span> <span class="st">&quot;equal_mass&quot;</span>,</a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="dt">lambda_seq =</span> <span class="kw">exp</span>(<span class="kw">seq</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">-10</span>, <span class="dt">length =</span> <span class="dv">100</span>))</a>
<a class="sourceLine" id="cb7-7" title="7">  ),</a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="dt">Q_fit_args =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="dt">fit_type =</span> <span class="st">&quot;glm&quot;</span>,</a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="dt">glm_formula =</span> <span class="st">&quot;Y ~ .^2&quot;</span></a>
<a class="sourceLine" id="cb7-11" title="11">  )</a>
<a class="sourceLine" id="cb7-12" title="12">)</a>
<a class="sourceLine" id="cb7-13" title="13">est_shift</a></code></pre></div>
<pre><code>## Counterfactual Mean of Shifted Treatment</code></pre>
<pre><code>## Intervention: Treatment + 0.5</code></pre>
<pre><code>## txshift Estimator: tmle</code></pre>
<pre><code>## Estimate: 1.8623</code></pre>
<pre><code>## Std. Error: 0.1542</code></pre>
<pre><code>## 95% CI: [1.56, 2.1646]</code></pre>
<div id="interlude-ensemble-machine-learning-with-sl3" class="section level3">
<h3>Interlude: Ensemble Machine Learning with <code>sl3</code></h3>
<p>To easily incorporate ensemble machine learning into the estimation procedure, <code>txshift</code> integrates with the <a href="https://tlverse.org/sl3/"><code>sl3</code> R package</a> <span class="citation">(Coyle, Hejazi, Malenica, et al. 2022)</span>. For a complete guide on using the <code>sl3</code> R package, consider consulting <a href="https://tlverse.org/tlverse-handbook/sl3.html">the chapter on Super Learning</a> in <span class="citation">van der Laan et al. (2022)</span>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">library</span>(sl3)</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="co"># SL learners to be used for most fits (e.g., IPCW, outcome regression)</span></a>
<a class="sourceLine" id="cb14-4" title="4">mean_learner &lt;-<span class="st"> </span>Lrnr_mean<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb14-5" title="5">glm_learner &lt;-<span class="st"> </span>Lrnr_glm<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb14-6" title="6">rf_learner &lt;-<span class="st"> </span>Lrnr_ranger<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb14-7" title="7">Q_lib &lt;-<span class="st"> </span>Stack<span class="op">$</span><span class="kw">new</span>(mean_learner, glm_learner, rf_learner)</a>
<a class="sourceLine" id="cb14-8" title="8">sl_learner &lt;-<span class="st"> </span>Lrnr_sl<span class="op">$</span><span class="kw">new</span>(<span class="dt">learners =</span> Q_lib, <span class="dt">metalearner =</span> Lrnr_nnls<span class="op">$</span><span class="kw">new</span>())</a>
<a class="sourceLine" id="cb14-9" title="9"></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="co"># SL learners for fitting the generalized propensity score fit</span></a>
<a class="sourceLine" id="cb14-11" title="11">hose_learner &lt;-<span class="st"> </span><span class="kw">make_learner</span>(Lrnr_density_semiparametric,</a>
<a class="sourceLine" id="cb14-12" title="12">  <span class="dt">mean_learner =</span> glm_learner</a>
<a class="sourceLine" id="cb14-13" title="13">)</a>
<a class="sourceLine" id="cb14-14" title="14">hese_learner &lt;-<span class="st"> </span><span class="kw">make_learner</span>(Lrnr_density_semiparametric,</a>
<a class="sourceLine" id="cb14-15" title="15">  <span class="dt">mean_learner =</span> rf_learner,</a>
<a class="sourceLine" id="cb14-16" title="16">  <span class="dt">var_learner =</span> glm_learner</a>
<a class="sourceLine" id="cb14-17" title="17">)</a>
<a class="sourceLine" id="cb14-18" title="18">g_lib &lt;-<span class="st"> </span>Stack<span class="op">$</span><span class="kw">new</span>(hose_learner, hese_learner)</a>
<a class="sourceLine" id="cb14-19" title="19">sl_learner_density &lt;-<span class="st"> </span>Lrnr_sl<span class="op">$</span><span class="kw">new</span>(</a>
<a class="sourceLine" id="cb14-20" title="20">  <span class="dt">learners =</span> g_lib,</a>
<a class="sourceLine" id="cb14-21" title="21">  <span class="dt">metalearner =</span> Lrnr_solnp_density<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb14-22" title="22">)</a></code></pre></div>
</div>
<div id="efficient-effect-estimates-with-machine-learning" class="section level3">
<h3>Efficient Effect Estimates with Machine Learning</h3>
<p>Using the framework provided by the <a href="https://github.com/tlverse/sl3/"><code>sl3</code> package</a>, the nuisance functions required for our efficient estimators may be fit with ensemble machine learning. The Super Learner algorithm <span class="citation">(van der Laan, Polley, and Hubbard 2007)</span> implemented in <code>sl3</code> uses the asymptotic optimality of V-fold cross-validation <span class="citation">(Dudoit and van der Laan 2005; van der Laan, Dudoit, and Keles 2004; van der Vaart, Dudoit, and van der Laan 2006)</span> to select an optimal prediction functions from a library or to construct an optimal combination of prediction functions.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" title="1">est_shift_sl &lt;-<span class="st"> </span><span class="kw">txshift</span>(</a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="dt">W =</span> W, <span class="dt">A =</span> A, <span class="dt">Y =</span> Y, <span class="dt">delta =</span> delta,</a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="dt">g_exp_fit_args =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="dt">fit_type =</span> <span class="st">&quot;sl&quot;</span>,</a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="dt">sl_learners_density =</span> sl_learner_density</a>
<a class="sourceLine" id="cb15-6" title="6">  ),</a>
<a class="sourceLine" id="cb15-7" title="7">  <span class="dt">Q_fit_args =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb15-8" title="8">    <span class="dt">fit_type =</span> <span class="st">&quot;sl&quot;</span>,</a>
<a class="sourceLine" id="cb15-9" title="9">    <span class="dt">sl_learners =</span> sl_learner</a>
<a class="sourceLine" id="cb15-10" title="10">  )</a>
<a class="sourceLine" id="cb15-11" title="11">)</a>
<a class="sourceLine" id="cb15-12" title="12">est_shift_sl</a></code></pre></div>
</div>
</div>
<div id="estimating-the-effects-of-additive-mtps-under-two-phase-sampling" class="section level2">
<h2>Estimating the Effects of Additive MTPs Under Two-Phase Sampling</h2>
<p>In case-cohort studies in which two-phase sampling is used, the data structure takes the from <span class="math inline">\(O = (W, \Delta A, Y, \Delta)\)</span> as previously discussed. Under such sampling, the <code>txshift()</code> function may still be used to estimate the causal effect of an additive MTP – only a few additional arguments need to be specified:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" title="1">est_shift_ipcw &lt;-<span class="st"> </span><span class="kw">txshift</span>(</a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="dt">W =</span> W, <span class="dt">A =</span> A, <span class="dt">Y =</span> Y, <span class="dt">delta =</span> delta,</a>
<a class="sourceLine" id="cb16-3" title="3">  <span class="dt">C_samp =</span> Delta_samp, <span class="dt">V =</span> <span class="kw">c</span>(<span class="st">&quot;W&quot;</span>, <span class="st">&quot;Y&quot;</span>),</a>
<a class="sourceLine" id="cb16-4" title="4">  <span class="dt">samp_fit_args =</span> <span class="kw">list</span>(<span class="dt">fit_type =</span> <span class="st">&quot;glm&quot;</span>),</a>
<a class="sourceLine" id="cb16-5" title="5">  <span class="dt">g_exp_fit_args =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="dt">fit_type =</span> <span class="st">&quot;hal&quot;</span>, <span class="dt">n_bins =</span> <span class="dv">5</span>,</a>
<a class="sourceLine" id="cb16-7" title="7">    <span class="dt">grid_type =</span> <span class="st">&quot;equal_mass&quot;</span>,</a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="dt">lambda_seq =</span> <span class="kw">exp</span>(<span class="kw">seq</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">-10</span>, <span class="dt">length =</span> <span class="dv">100</span>))</a>
<a class="sourceLine" id="cb16-9" title="9">  ),</a>
<a class="sourceLine" id="cb16-10" title="10">  <span class="dt">Q_fit_args =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb16-11" title="11">    <span class="dt">fit_type =</span> <span class="st">&quot;glm&quot;</span>,</a>
<a class="sourceLine" id="cb16-12" title="12">    <span class="dt">glm_formula =</span> <span class="st">&quot;Y ~ .^2&quot;</span></a>
<a class="sourceLine" id="cb16-13" title="13">  ),</a>
<a class="sourceLine" id="cb16-14" title="14">  <span class="dt">eif_reg_type =</span> <span class="st">&quot;glm&quot;</span></a>
<a class="sourceLine" id="cb16-15" title="15">)</a>
<a class="sourceLine" id="cb16-16" title="16">est_shift_ipcw</a></code></pre></div>
<pre><code>## Counterfactual Mean of Shifted Treatment</code></pre>
<pre><code>## Intervention: Treatment + 0.5</code></pre>
<pre><code>## txshift Estimator: tmle</code></pre>
<pre><code>## Estimate: 1.9515</code></pre>
<pre><code>## Std. Error: 0.1398</code></pre>
<pre><code>## 95% CI: [1.6776, 2.2254]</code></pre>
<p>Note that we specify a few additional arguments in the call to <code>txshift()</code>, including <code>C_samp</code>, the indicator of inclusion in the two-phase sample; <code>V</code>, the set of other variables that may affect the sampling decision (in this case, both the baseline covariates and the outcome); <code>samp_fit_args</code>, which indicates how the sampling mechanism ought to be estimated; and <code>eif_reg_type</code>, which indicates how a particular reduced-dimension nuisance regression ought to be estimated (see <span class="citation">Rose and van der Laan (2011)</span> and <span class="citation">Hejazi et al. (2020)</span> for details). This last argument only has options for using a GLM or the highly adaptive lasso (HAL), a nonparametric regression estimator, using the <a href="https://github.com/tlverse/hal9001/"><code>hal9001</code> package</a> [<span class="citation">Coyle, Hejazi, Phillips, et al. (2022)</span>; hejazi2020hal9001-joss]. In practice, we recommend leaving this argument to the default and fitting this nuisance function with HAL; however, this is significantly more costly computationally.</p>
</div>
<div id="statistical-inference-for-one-step-and-tml-estimators" class="section level2">
<h2>Statistical Inference for One-step and TML Estimators</h2>
<p>The efficient estimators implemented in <code>txshift</code> are asymptotically linear; thus, the estimator <span class="math inline">\(\psi_n\)</span> converges to the true parameter value <span class="math inline">\(\psi_0\)</span>: <span class="math display">\[\psi_n - \psi_0 = (P_n - P_0) \cdot D(\bar{Q}_n^{\star}, g_n) +
  R(\hat{P}^{\star}, P_0),\]</span> which yields <span class="math display">\[\psi_n - \psi_0 = (P_n - P_0) \cdot D(P_0) + o_P \left( \frac{1}{\sqrt{n}}
 \right),\]</span> provided the following conditions,</p>
<ol style="list-style-type: decimal">
<li>if <span class="math inline">\(D(\bar{Q}_n^{\star}, g_n)\)</span> converges to <span class="math inline">\(D(P_0)\)</span> in <span class="math inline">\(L_2(P_0)\)</span> norm;</li>
<li>the size of the class of functions considered for estimation of <span class="math inline">\(\bar{Q}_n^{\star}\)</span> and <span class="math inline">\(g_n\)</span> is bounded (technically, <span class="math inline">\(\exists \mathcal{F}\)</span> such that <span class="math inline">\(D(\bar{Q}_n^{\star}, g_n) \in \mathcal{F}\)</span> with high probability, where <span class="math inline">\(\mathcal{F}\)</span> is a Donsker class); and</li>
<li>the remainder term <span class="math inline">\(R(\hat{P}^{\star}, P_0)\)</span> decays as <span class="math inline">\(o_P \left( \frac{1}{\sqrt{n}} \right)\)</span>.</li>
</ol>
<p>By the central limit theorem, the estimators then have a Gaussian limiting distribution, <span class="math display">\[\sqrt{n}(\psi_n - \psi) \to N(0, V(D(P_0))),\]</span> where <span class="math inline">\(V(D(P_0))\)</span> is the variance of the efficient influence function (or canonical gradient).</p>
<p>The above implies that <span class="math inline">\(\psi_n\)</span> is a <span class="math inline">\(\sqrt{n}\)</span>-consistent estimator of <span class="math inline">\(\psi\)</span>, that it is asymptotically normal (as given above), and that it is locally efficient. This allows us to build Wald-type confidence intervals in a straightforward manner:</p>
<p><span class="math display">\[\psi_n \pm z_{\alpha} \cdot \frac{\sigma_n}{\sqrt{n}},\]</span> where <span class="math inline">\(\sigma_n^2\)</span> is an estimator of <span class="math inline">\(V(D(P_0))\)</span>. The estimator <span class="math inline">\(\sigma_n^2\)</span> may be obtained using the bootstrap or computed directly via the following</p>
<p><span class="math display">\[\sigma_n^2 = \frac{1}{n} \sum_{i = 1}^{n} D^2(\bar{Q}_n^{\star}, g_n)(O_i).\]</span></p>
<p>Such confidence intervals may easily be created with the <code>confint</code> method:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" title="1">(ci_est_shift &lt;-<span class="st"> </span><span class="kw">confint</span>(est_shift))</a></code></pre></div>
<pre><code>##   lwr_ci      est   upr_ci 
## 1.559997 1.862286 2.164576</code></pre>
</div>
<div id="advanced-usage-user-specified-nuisance-regressions" class="section level2">
<h2><em>Advanced Usage:</em> User-Specified Nuisance Regressions</h2>
<p>In some special cases it may be useful for the experienced user to compute the treatment mechanism, censoring mechanism, outcome regression, and sampling mechanism fits separately (i.e., outside of the <code>txshift</code> wrapper function), instead applying the wrapper only to construct an efficient one-step or TML estimator. In such cases, the optional arguments ending in <code>_ext</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" title="1"><span class="co"># compute censoring mechanism and produce IPC weights externally</span></a>
<a class="sourceLine" id="cb25-2" title="2">pi_mech &lt;-<span class="st"> </span><span class="kw">plogis</span>(W)</a>
<a class="sourceLine" id="cb25-3" title="3">ipcw_out &lt;-<span class="st"> </span>pi_mech</a>
<a class="sourceLine" id="cb25-4" title="4"></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="co"># compute treatment mechanism (propensity score) externally</span></a>
<a class="sourceLine" id="cb25-6" title="6"><span class="co">## first, produce the down-shifted treatment data</span></a>
<a class="sourceLine" id="cb25-7" title="7">gn_downshift &lt;-<span class="st"> </span><span class="kw">dnorm</span>(A <span class="op">-</span><span class="st"> </span>delta, <span class="dt">mean =</span> tx_mult <span class="op">*</span><span class="st"> </span>W, <span class="dt">sd =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb25-8" title="8"><span class="co">## next, initialize and produce the up-shifted treatment data</span></a>
<a class="sourceLine" id="cb25-9" title="9">gn_upshift &lt;-<span class="st"> </span><span class="kw">dnorm</span>(A <span class="op">+</span><span class="st"> </span>delta, <span class="dt">mean =</span> tx_mult <span class="op">*</span><span class="st"> </span>W, <span class="dt">sd =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb25-10" title="10"><span class="co">## now, initialize and produce the up-up-shifted (2 * delta) treatment data</span></a>
<a class="sourceLine" id="cb25-11" title="11">gn_upupshift &lt;-<span class="st"> </span><span class="kw">dnorm</span>(A <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta, <span class="dt">mean =</span> tx_mult <span class="op">*</span><span class="st"> </span>W, <span class="dt">sd =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb25-12" title="12"><span class="co">## then, initialize and produce the un-shifted treatment data</span></a>
<a class="sourceLine" id="cb25-13" title="13">gn_noshift &lt;-<span class="st"> </span><span class="kw">dnorm</span>(A, <span class="dt">mean =</span> tx_mult <span class="op">*</span><span class="st"> </span>W, <span class="dt">sd =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb25-14" title="14"><span class="co">## finally, put it all together into an object like what&#39;s produced internally</span></a>
<a class="sourceLine" id="cb25-15" title="15">gn_out &lt;-<span class="st"> </span><span class="kw">as.data.table</span>(<span class="kw">cbind</span>(gn_downshift, gn_noshift, gn_upshift,</a>
<a class="sourceLine" id="cb25-16" title="16">                              gn_upupshift))[C <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ]</a>
<a class="sourceLine" id="cb25-17" title="17"><span class="kw">setnames</span>(gn_out, <span class="kw">c</span>(<span class="st">&quot;downshift&quot;</span>, <span class="st">&quot;noshift&quot;</span>, <span class="st">&quot;upshift&quot;</span>, <span class="st">&quot;upupshift&quot;</span>))</a>
<a class="sourceLine" id="cb25-18" title="18"></a>
<a class="sourceLine" id="cb25-19" title="19"><span class="co"># compute outcome regression externally</span></a>
<a class="sourceLine" id="cb25-20" title="20"><span class="co"># </span><span class="al">NOTE</span><span class="co">: transform Y to lie in the unit interval and bound predictions such that</span></a>
<a class="sourceLine" id="cb25-21" title="21"><span class="co">#       no values fall near the bounds of the interval</span></a>
<a class="sourceLine" id="cb25-22" title="22">Qn_noshift &lt;-<span class="st"> </span>(W <span class="op">+</span><span class="st"> </span>A <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(Y)) <span class="op">/</span><span class="st"> </span><span class="kw">diff</span>(<span class="kw">range</span>(Y))</a>
<a class="sourceLine" id="cb25-23" title="23">Qn_upshift &lt;-<span class="st"> </span>(W <span class="op">+</span><span class="st"> </span>A <span class="op">+</span><span class="st"> </span>delta <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(Y)) <span class="op">/</span><span class="st"> </span><span class="kw">diff</span>(<span class="kw">range</span>(Y))</a>
<a class="sourceLine" id="cb25-24" title="24">Qn_noshift[Qn_noshift <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="fl">0.025</span></a>
<a class="sourceLine" id="cb25-25" title="25">Qn_noshift[Qn_noshift <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="fl">0.975</span></a>
<a class="sourceLine" id="cb25-26" title="26">Qn_upshift[Qn_upshift <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="fl">0.025</span></a>
<a class="sourceLine" id="cb25-27" title="27">Qn_upshift[Qn_upshift <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="fl">0.975</span></a>
<a class="sourceLine" id="cb25-28" title="28">Qn_out &lt;-<span class="st"> </span><span class="kw">as.data.table</span>(<span class="kw">cbind</span>(Qn_noshift, Qn_upshift))[C <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ]</a>
<a class="sourceLine" id="cb25-29" title="29"><span class="kw">setnames</span>(Qn_out, <span class="kw">c</span>(<span class="st">&quot;noshift&quot;</span>, <span class="st">&quot;upshift&quot;</span>))</a>
<a class="sourceLine" id="cb25-30" title="30"></a>
<a class="sourceLine" id="cb25-31" title="31"><span class="co"># construct efficient estimator by applying wrapper function </span></a>
<a class="sourceLine" id="cb25-32" title="32">est_shift_spec &lt;-<span class="st"> </span><span class="kw">txshift</span>(</a>
<a class="sourceLine" id="cb25-33" title="33">  <span class="dt">W =</span> W, <span class="dt">A =</span> A, <span class="dt">Y =</span> Y, <span class="dt">delta =</span> delta,</a>
<a class="sourceLine" id="cb25-34" title="34"> <span class="dt">samp_fit_args =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb25-35" title="35"> <span class="dt">samp_fit_ext =</span> ipcw_out,</a>
<a class="sourceLine" id="cb25-36" title="36"> <span class="dt">g_exp_fit_args =</span> <span class="kw">list</span>(<span class="dt">fit_type =</span> <span class="st">&quot;external&quot;</span>),</a>
<a class="sourceLine" id="cb25-37" title="37"> <span class="dt">Q_fit_args =</span> <span class="kw">list</span>(<span class="dt">fit_type =</span> <span class="st">&quot;external&quot;</span>),</a>
<a class="sourceLine" id="cb25-38" title="38"> <span class="dt">gn_exp_fit_ext =</span> gn_out,</a>
<a class="sourceLine" id="cb25-39" title="39"> <span class="dt">Qn_fit_ext =</span> Qn_out</a>
<a class="sourceLine" id="cb25-40" title="40">)</a></code></pre></div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-coyle-sl3-rpkg">
<p>Coyle, Jeremy R, Nima S Hejazi, Ivana Malenica, Rachael V Phillips, and Oleg Sofrygin. 2022. <em>sl3: Modern Machine Learning Pipelines for Super Learning</em>. <a href="https://doi.org/10.5281/zenodo.1342293">https://doi.org/10.5281/zenodo.1342293</a>.</p>
</div>
<div id="ref-coyle-hal9001-rpkg">
<p>Coyle, Jeremy R, Nima S Hejazi, Rachael V Phillips, Lars W van der Laan, and Mark J van der Laan. 2022. <em>hal9001: The Scalable Highly Adaptive Lasso</em>. <a href="https://doi.org/10.5281/zenodo.3558313">https://doi.org/10.5281/zenodo.3558313</a>.</p>
</div>
<div id="ref-diaz2012population">
<p>Dı́az, Iván, and Mark J van der Laan. 2012. “Population Intervention Causal Effects Based on Stochastic Interventions.” <em>Biometrics</em> 68 (2): 541–49.</p>
</div>
<div id="ref-diaz2018stochastic">
<p>———. 2018. “Stochastic Treatment Regimes.” In <em>Targeted Learning in Data Science: Causal Inference for Complex Longitudinal Studies</em>, 167–80. Springer Science &amp; Business Media.</p>
</div>
<div id="ref-dudoit2005asymptotics">
<p>Dudoit, Sandrine, and Mark J van der Laan. 2005. “Asymptotics of Cross-Validated Risk Estimation in Estimator Selection and Performance Assessment.” <em>Statistical Methodology</em> 2 (2): 131–54.</p>
</div>
<div id="ref-gilbert2021covpn">
<p>Gilbert, Peter B, Youyi Fong, David Benkeser, Jessica Andriesen, Bhavesh Borate, Marco Carone, Lindsay N Carpp, et al. 2021. “CoVPN Covid-19 Vaccine Efficacy Trial Immune Correlates Statistical Analysis Plan.” <a href="https://doi.org/10.6084/m9.figshare.13198595">https://doi.org/10.6084/m9.figshare.13198595</a>.</p>
</div>
<div id="ref-haneuse2013estimation">
<p>Haneuse, Sebastian, and Andrea Rotnitzky. 2013. “Estimation of the Effect of Interventions That Modify the Received Treatment.” <em>Statistics in Medicine</em> 32 (30): 5260–77.</p>
</div>
<div id="ref-hejazi2020efficient">
<p>Hejazi, Nima S, Mark J van der Laan, Holly E Janes, Peter B Gilbert, and David C Benkeser. 2020. “Efficient Nonparametric Inference on the Effects of Stochastic Interventions Under Two-Phase Sampling, with Applications to Vaccine Efficacy Trials.” <em>Biometrics</em> 77 (4): 1241–53. <a href="https://doi.org/10.1111/biom.13375">https://doi.org/10.1111/biom.13375</a>.</p>
</div>
<div id="ref-pearl2000causality">
<p>Pearl, Judea. 2000. <em>Causality</em>. Cambridge University Press.</p>
</div>
<div id="ref-rose2011targeted2sd">
<p>Rose, Sherri, and Mark J van der Laan. 2011. “A Targeted Maximum Likelihood Estimator for Two-Stage Designs.” <em>International Journal of Biostatistics</em> 7 (1): 1–21.</p>
</div>
<div id="ref-vdl2022targeted">
<p>van der Laan, Mark J, Jeremy R Coyle, Nima S Hejazi, Ivana Malenica, Rachael V Phillips, and Alan E Hubbard. 2022. <em>Targeted Learning in <code>R</code>: A Causal Data Science Handbook</em>. CRC Press. <a href="https://tlverse.org/tlverse-handbook/">https://tlverse.org/tlverse-handbook/</a>.</p>
</div>
<div id="ref-vdl2004asymptotic">
<p>van der Laan, Mark J, Sandrine Dudoit, and Sunduz Keles. 2004. “Asymptotic Optimality of Likelihood-Based Cross-Validation.” <em>Statistical Applications in Genetics and Molecular Biology</em> 3 (1): 1–23.</p>
</div>
<div id="ref-vdl2007super">
<p>van der Laan, Mark J, Eric C Polley, and Alan E Hubbard. 2007. “Super Learner.” <em>Statistical Applications in Genetics and Molecular Biology</em> 6 (1).</p>
</div>
<div id="ref-vdl2011targeted">
<p>van der Laan, Mark J, and Sherri Rose. 2011. <em>Targeted Learning: Causal Inference for Observational and Experimental Data</em>. Springer Science &amp; Business Media.</p>
</div>
<div id="ref-vdl2018targeted">
<p>———. 2018. <em>Targeted Learning in Data Science: Causal Inference for Complex Longitudinal Studies</em>. Springer Science &amp; Business Media.</p>
</div>
<div id="ref-vdv2006oracle">
<p>van der Vaart, Aad W, Sandrine Dudoit, and Mark J van der Laan. 2006. “Oracle Inequalities for Multi-Fold Cross Validation.” <em>Statistics &amp; Decisions</em> 24 (3): 351–71.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
